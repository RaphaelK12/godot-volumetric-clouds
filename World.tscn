[gd_scene load_steps=11 format=2]

[ext_resource path="res://addons/shader_procedural_textures/Worley_texture.tscn" type="PackedScene" id=1]
[ext_resource path="res://MouseLookCamera.gd" type="Script" id=2]
[ext_resource path="res://CloudRenderer.gd" type="Script" id=3]

[sub_resource type="ProceduralSky" id=1]

[sub_resource type="Environment" id=2]
background_mode = 2
background_sky = SubResource( 1 )

[sub_resource type="QuadMesh" id=3]
size = Vector2( 2, 2 )

[sub_resource type="Shader" id=4]
code = "shader_type spatial;
render_mode unshaded;

uniform sampler2D camera_view;
uniform sampler2D worley;

uniform float worley_uv_scale = 0.0001;
uniform float depth = 128.0;

uniform int num_steps = 1024;
uniform float step_length = 10.0;

uniform mat4 global_transform;

varying vec3 offset;
varying vec3 vertex_pos;
varying vec3 start_direction;
varying mat4 CAMERA;

uniform float fov;
uniform vec3 front = vec3(1.0, 0.0, 0.0);
uniform vec3 up = vec3(0.0, 1.0, 0.0);

uniform float cloud_begin = 2000.0;
uniform float cloud_end = 5000.0;

vec4 texture3d(sampler2D p_texture, vec3 p_uvw) {
	vec3 mod_uvw = mod(p_uvw  * worley_uv_scale + offset, 1.0);
	
	float fd = mod_uvw.z * depth;
	float fz = floor(fd);
	
	vec2 uv1 = vec2(mod_uvw.x, (mod_uvw.y + fz) / depth);
	vec2 uv2 = vec2(mod_uvw.x, mod((mod_uvw.y + fz + 1.0) / depth, 1.0));
	
	vec4 col1 = texture(p_texture, uv1);
	vec4 col2 = texture(p_texture, uv2);
	
	return mix(col1, col2, fd - fz);
}

float cloud_density(vec3 p_pos) {
	vec4 density_in_texture = texture3d(worley, p_pos);
	
	// join our octaves
	float value = density_in_texture.r + (0.5 * density_in_texture.g) + (0.25 * density_in_texture.b);
	
	// inverse and clamp
	value = clamp(1.0 - value, 0.0, 1.0);
	
	return value;
}

// Adapted from https://github.com/PLUkraine/raymarching-godot
vec3 get_ray_direction(vec2 resolution, vec2 uv)
{
	float aspect = resolution.x / resolution.y;
	float fov2 = radians(fov) / 2.0;
	
	// convert coordinates from [0, 1] to [-1, 1]
	// and invert y axis to flow from bottom to top
	vec2 screenCoord = (uv - 0.5) * 2.0;
	screenCoord.x *= aspect;
	screenCoord.y = -screenCoord.y;
	
	vec2 offsets = screenCoord * tan(fov2);
	
	vec3 rayFront = -normalize(global_transform[2].xyz);
	vec3 rayRight = normalize(cross(rayFront, normalize(global_transform[1].xyz)));
	vec3 rayUp = cross(rayRight, rayFront);
	vec3 rayDir = rayFront + rayRight * offsets.x + rayUp * offsets.y;
	
	return normalize(rayDir);
}

void vertex() {
	POSITION = vec4(VERTEX, 1.0);
	CAMERA = CAMERA_MATRIX;
}

void fragment() {
	float screen_depth = texture(DEPTH_TEXTURE, SCREEN_UV).x;
	vec3 ndc = vec3(SCREEN_UV, screen_depth) * 2.0 - 1.0;
	vec4 view = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	view.xyz /= view.w;
	float linear_depth = -view.z;
	
	vec4 world = CAMERA * INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	vec3 world_position = world.xyz / world.w;
	
	vec3 start_position = CAMERA[3].xyz * step_length;
	vec3 direction = get_ray_direction(vec2(1024.0, 600.0), UV);
	
	// March forward
	float distance_to_camera = 0.0f;
	vec3 cloud_color = vec3(1.0, 1.0, 1.0);
	float cloud_alpha = 0.0f;
	
	for (int i = 0; i < num_steps; i++) {
		vec3 position = (start_position + distance_to_camera * direction);
		distance_to_camera += step_length;
		
		if (position.y < cloud_begin || position.y > cloud_end) { continue; }
		
		float density = cloud_density(position) * (1.0 + -cos(((position.y - (cloud_begin)) / (cloud_end - cloud_begin)) * 6.2831853)) / 2.0;
		
		cloud_alpha += density * 0.005;
	}
	
	ALBEDO = cloud_color;
	ALPHA = cloud_alpha;
}"

[sub_resource type="ViewportTexture" id=5]
viewport_path = NodePath("Worley_texture")

[sub_resource type="ShaderMaterial" id=6]
resource_local_to_scene = true
shader = SubResource( 4 )
shader_param/worley_uv_scale = 0.0001
shader_param/depth = 128.0
shader_param/num_steps = 1024
shader_param/step_length = 10.0
shader_param/global_transform = null
shader_param/fov = null
shader_param/front = Vector3( 1, 0, 0 )
shader_param/up = Vector3( 0, 1, 0 )
shader_param/cloud_begin = 2000.0
shader_param/cloud_end = 5000.0
shader_param/worley = SubResource( 5 )

[sub_resource type="PrismMesh" id=9]
size = Vector3( 500, 100, 200 )

[node name="World" type="Spatial"]

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource( 2 )

[node name="Worley_texture" parent="." instance=ExtResource( 1 )]
gui_disable_input = true
texture_size = Vector3( 256, 256, 64 )

[node name="CameraControl" type="Spatial" parent="."]
script = ExtResource( 2 )

[node name="Head" type="Spatial" parent="CameraControl"]

[node name="Camera" type="Camera" parent="CameraControl/Head"]
current = true
far = 500.0

[node name="CloudRenderer" type="MeshInstance" parent="CameraControl/Head/Camera"]
mesh = SubResource( 3 )
material/0 = SubResource( 6 )
script = ExtResource( 3 )

[node name="MeshInstance" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -51, 0 )
mesh = SubResource( 9 )
material/0 = null
